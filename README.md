Enhanced DES (E-DES): An Exploration and Implementation

1. Introduction

The Data Encryption Standard (DES) has been a pivotal symmetric block cipher in cryptography. However, it faced obsolescence due to its slowness and short 56-bit key size. This project introduces a variant called Enhanced DES (E-DES) which addresses these issues by using 256-bit keys and faster operations within Feistel Networks.

2. Homework

2.1 E-DES Implementation

E-DES resembles DES but introduces several changes. It uses 16 Feistel Networks and unique S-Boxes generated from a 256-bit key. The S-Boxes are key-dependent, providing an extra layer of security against cryptanalysis. Each S-Box transforms a byte-long input, and across all S-Boxes, there must be exactly 16 identical byte values.

2.2 Applications

Three applications were developed: encrypt, decrypt, and speed, each in two different languages to ensure cross-language compatibility.

    Encrypt and Decrypt: These applications accept a password to generate the E-DES key and an option to default to DES. They process input from stdin, encrypt or decrypt it, and output the result to stdout.

    Speed: This application measures the time taken to encrypt and decrypt a 4KiB buffer using DES and E-DES. A minimum of 100,000 measurements were taken, and the lowest values (maximum speed) were reported.

3. Evaluation

The project was evaluated based on the implementation of E-DES, the applications, and a written report.

4. Homework Delivery

The project, including code and a report detailing the implementation and strategies followed, was submitted through the provided E-learning link.

5. Implementation Strategy

The implementation strategy involved creating the E-DES algorithm with a focus on speed and security. The S-Boxes were generated using a Linear Congruential Generator to ensure randomness and uniqueness. The Feistel Networks used these S-Boxes for byte transformation.

6. Applications

    E-DES Module: Implemented in C and Python, this module included functions to generate S-Boxes, perform encryption, and decryption.

    Encrypt & Decrypt Applications: Developed in C and Python, these applications used the E-DES module to perform encryption and decryption respectively. DES encryption and decryption were also implemented for comparison.

    Speed Application: Developed in C, this application measured the time taken for encryption and decryption using DES and E-DES. Loop unrolling was employed for accurate measurements.

7. Results and Discussion

The results showed that E-DES, while being secure with a 256-bit key, was significantly faster than the traditional DES. This is attributed to the key-dependent S-Boxes and the exclusion of permutations.

8. Conclusion

The E-DES implementation successfully achieved the project goals of creating a DES-like cipher that is faster and uses a longer key. The cross-language compatibility of the applications also showcases the flexibility and usability of E-DES.

9. Acknowledgments

Any code or libraries borrowed from external sources were duly acknowledged in the report and the code itself.



The provided code represents an implementation of a symmetric-key block cipher, akin to the Data Encryption Standard (DES) algorithm, but modified and extended in a custom manner which we'll refer to as E-DES (Extended DES). The code includes both C and Python implementations for encrypting and decrypting data using both DES and E-DES. Below is an analysis of the code and the strategies followed:
1. Linear Congruential Generator (LCG):

The code defines a simple Linear Congruential Generator (LCG) for generating pseudo-random numbers. LCG is defined by the recurrence relation:
Xn+1=(a⋅Xn+c)mod  m
Xn+1​=(a⋅Xn​+c)modm

Here, a=1103515245a=1103515245, c=12345c=12345, and m=231m=231.
2. E-DES Implementation:

The E-DES algorithm works similarly to DES, using a Feistel network structure but with custom substitution boxes (S-Boxes) generated from a given key.
2.1 S-Box Generation:

    Seed Generation: A seed for the LCG is generated by XORing and rotating bits from the key.
    Permutation Generation: 16 S-Boxes are generated with values from 0 to 255.
    Zero Replacement: Ensures only one zero exists in each S-Box and replaces extra zeros with missing values.

2.2 Feistel Function:

    It takes an input block and an S-Box and produces an output block by selecting and mixing the input bytes using the S-Box.

2.3 E-DES Encryption:

    Block Split: The plaintext is divided into two halves, L and R.
    16 Rounds: The Feistel function is applied 16 times, each time using one of the 16 generated S-Boxes.
    Block Merge: The modified R and L blocks are concatenated to form the ciphertext.

2.4 E-DES Decryption:

    Similar to encryption, but the rounds are applied in reverse order.

2.5 Padding:

    PKCS7: The data is padded to a multiple of the block size using PKCS7 padding.

3. DES Implementation:

The code also provides functions for encrypting and decrypting data using the standard DES algorithm. The DES functions utilize a library (Crypto.Cipher.DES in Python) to perform encryption and decryption.
4. Testing and Benchmarking:

The C code includes a test file that compares the performance of DES and E-DES by measuring the time taken to encrypt and decrypt random data.
5. CLI Tools:

The code provides command-line tools (both in C and Python) for encrypting and decrypting data using either DES or E-DES.
Results:

    Encryption and Decryption: The code successfully encrypts and decrypts data using DES and E-DES algorithms.
    Benchmarking: While specific results are not provided, the code is designed to compare the performance of DES and E-DES.

Conclusion:

The implemented E-DES algorithm is a variant of the standard DES algorithm with custom S-Boxes generated from a given key. The code provides a comprehensive suite for testing, encrypting, and decrypting data using both DES and E-DES, and includes implementations in both C and Python. The benchmarking tool would help in comparing the performance of the two algorithms.